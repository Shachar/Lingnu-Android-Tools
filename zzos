#!/usr/bin/perl

# zzos - decompile Android resources compiled with aapt
# Copyright (C) 2011 Lingnu Open Source Consulting Ltd.
# Written by Shachar Shemesh
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

use Getopt::Long;
use File::Basename;
use File::Path qw(make_path);
use POSIX;

use feature "switch";

# Hashes for tracking the cross references

# The main hash. Key is integer resource number. Value is "package:class/name" string
my %references, %framework_references;
# Flags of resources. Key is same as above. Value is integer
my %references_flags, %framework_references_flags;
# Bags of attribs. Key is string "package:name". Value is reference to hash:
#    Key is name of resource (as in %attrib_references). Value is integer, except for "flags", where
#    value is a hash reference:
#       Key is integer bit field or value. Value is the name of field.
my %attrib_bags, %framework_attrib_bags;
# Reverse hash of %references. Key is %references value, value is %references key.
my %rev_references, %framework_rev_references;
my $package_name, $apk_package_name, $package_ext;

my %class_map=(
        raw=>undef,
        layout=>undef,
        xml=>undef,
        anim=>undef,
        menu=>undef,
        animator=>undef,
        accelerate_quad=>undef,
        interpolator=>undef,
        mipmap=>undef,
        id=>\&parse_id_value,
        string=>\&parse_string_value,
        dimen=>\&parse_dimen_value,
        color=>\&parse_color_value,
        drawable=>\&parse_color_value,
        bool=>\&parse_bool_value,
        integer=>\&parse_int_value,
        fraction=>\&parse_fraction_value,
    );

$REF_PUBLIC=    0x40000000;
$REF_HARDCODE=  0x80000000;
$REF_INTERNAL=  0x00000001;
$REF_SPEC=      0x00000002;
$REF_USED=      0x00000004;
$REF_RENAMED=   0x00000010;
$REF_DUPLICATE= 0x00000020;

# Attribute type bits
%attrib_types=(
        0x00000001 => [ "reference", 0x01 ],
        0x00000002 => [ "string", 0x03 ],
        0x00000004 => [ "integer", 0x10 ],
        0x00000008 => [ "boolean", 0x12 ],
        0x00000010 => [ "color", 0x1c ],
        0x00000020 => [ "float", 0x04 ],
        0x00000040 => [ "dimension", 0x05 ],
        0x00000080 => [ "fraction", 0x06 ],
        0x00010000 => [ "enum", undef ],
        0x00020000 => [ "flags", undef ],
        );

%attrib_references=(
        0x01000000 => "format",
        0x01000001 => "min",
        0x01000002 => "max",
        0x01000003 => "localization", # 0 - not required, 1 - suggested
        );

%plural_references=(
        0x01000004 => "other",
        0x01000005 => "zero",
        0x01000006 => "one",
        0x01000007 => "two",
        0x01000008 => "few",
        0x01000009 => "many",
        );

# Hard code null
$framework_references{0}="null";
$framework_references_flags{0}=$REF_PUBLIC|$REF_HARDCODE;

# Bit counting cache for num_set_bits in 4 bit values.
my @bitcount=( 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 );

# Resource type open file descriptors
my %type_files;

sub help
{
    print STDERR <<EOM;
zzos [options] apk...

Options:
--framework     Given APK provides framework for this APK
--output        directory where to create the extracted APK dirs. Default is current directory.
--nosubdir      "output" specifies the actual directory to create.
EOM
    exit 1;
}

my (@framework_names, $outdir, $nosubdir);

$outdir=".";

GetOptions("framework=s" => \@framework_names, "output=s" => \$outdir, "nosubdir" => \$nosubdir )
    or help();

for( @framework_names ) {
    read_resources( $_, $outdir, 1 ) or die "Failed to read framework resources for $_";
    %framework_references = %references;
    %framework_references_flags = %references_flags;
    %framework_attrib_bags = %attrib_bags;
    %framework_rev_references = %rev_references;
}

if( $#ARGV==-1 ) {
    help();

    exit 0;
}

my ($apkpath, $delayed_fail);
my $delayed_fail=0;
while( $apkpath = shift @ARGV ) {
    # For each APK to be processed
    my ($apkname, $apkdir ) = fileparse( $apkpath, ( ".apk" ) );

    my $real_outdir="$outdir";
    $real_outdir.="/$apkname" if ! $nosubdir;
    
    if( process_apk( $apkpath, "$real_outdir" ) ) {
        $delayed_fail = 1;
        print STDERR "process_apk failed for $apkname\n";
    }
}

exit $delayed_fail;

sub process_apk
{
    my ( $apkpath, $outdir ) = @_;

    if( !mkdir "$outdir" ) {
        print STDERR "Failed to create directory $outdir: $!\n";
        return 1;
    }

    set_package_name( $apkpath );
    # List of files to be unzipped as they are
    my @ziplist, @patch9list, %rename_list;
    print STDOUT "Processing $apkpath\n";

    if( ! read_resources( $apkpath, $outdir, 0 ) ) {
        return 1;
    }

    # Get a list of files in the package
    if( ! open( APKLIST, "-|", "aapt", ("l", $apkpath)) ) {
        print STDERR "Failed to open $apkpath: $!\n";

        return 1;
    }

    # Scan all the files in the APK
    while( <APKLIST> ) {
        chomp;
        my $file=$_;

        if( m/^resources.arsc$/ ) {
            # Do nothing. We handle this file through aapt dump resources.
        } elsif( m'^res/raw.*\.xml$' ) {
            # .xml files under raw are not compiled.
            push @ziplist, $_;
        } elsif( m'^AndroidManifest.xml$' ) {
            # AndroidManifest.xml is, obviously, an XML file.
            if( !xml_decompile( $apkpath, $_, $outdir ) ) {
                return 1;
            }
        } elsif( m'^res/.*\.xml$' ) {
            # All other .xml files under res are compiled
            if( !xml_decompile( $apkpath, $_, $outdir ) ) {
                return 1;
            }
        } elsif( m'^res/(xml|anim|layout|menu)' ) {
            # ALL files under those directories are xmls, regardless of extension
            if( !xml_decompile( $apkpath, $_, $outdir ) ) {
                return 1;
            }
        } elsif( m'^res/drawable.*\.9\.png$' ) {
            # 9Patch png's need to be decompiled after being extracted
            push @ziplist, $_;
            push @patch9list, $_;
        } else {
            push @ziplist, $_;
        }

        # lang-country combination get their "r" removed by aapt
        if( $file=~'^res/([^/]+)-([a-z]{2})-([A-Z]{2})(-[^/]*)?/' ) {
            my $name="res/$1-$2-$3$4";
            if( ! exists $rename_list{$name} ) {
                $rename_list{$name}="res/$1-$2-r$3$4";
            }
        }
    }

    close APKLIST;

    # Extract all of the files that need simple extraction
    system "unzip", ( "-q", $apkpath, @ziplist, "-d", $outdir );

    # De9patch all relevant files
    de9patch( $outdir, \@patch9list );

    # Rename incorrectly named directories
    for( keys %rename_list ) {
        rename "$outdir/$_", "$outdir/$rename_list{$_}";
    }

    return dump_values( $apkpath, $outdir );
}

sub de9patch
{
    my( $outdir, $filelist )=@_;

    for( @$filelist ) {
        print "  Decompiling $_\n";
        (system "de9patch", ( "$outdir/$_", "$outdir/$_.tmp" ))==0
                or die "Failed to decompile $_";
        rename "$outdir/$_.tmp", "$outdir/$_"
                or die "Failed to rename: $!";
    }
}

sub read_resources
{
    my ( $apkpath, $outdir, $framework ) = @_;

    # Inherit all of the framework references
    %references = %framework_references;
    %references_flags = %framework_references_flags;
    %attrib_bags = %framework_attrib_bags;
    %rev_references = %framework_rev_references;

    open RESFILE, "-|", "aapt", ( "d", "--values", "resources", $apkpath ) or
            die "Failed to extract resources";

    my $state=0;
    my ($counter, $bag_index);
    my $bag, $bag_flags;
    while( <RESFILE> ) {
        chomp;

        my ($index, $package, $str);
        my $flags=$framework ? 0 : $REF_INTERNAL;

        $index=undef;

        if( $state == 0 ) {
            # Base state - usual processing
            if( m'Package Group \d+ id=\d+ packageCount=\d+ name=(.+)$' ) {
                if( !$framework ) {
                    # If this is not a framework APK read, set the package name
                    $package_name=$1;
                } else {
                    $package_name=undef;
                }
            } elsif( m'^ *(spec )?resource 0x([0-9a-f]{8}) ([^:/]+):([^:/]+)/([^:]+): flags=0x([0-9a-f]+)' )
            {
                ($index, $package, $str)=( hex($2), $3, "$4/$5");

                if( $1 ) {
                    $flags|=$REF_SPEC;
                }

                if( (hex($6)&0x40000000)!=0 ) {
                    $flags|=$REF_PUBLIC;
                }

                if( exists( $references{$index} ) ) {
                    # A package sometimes defines attributes belonging to the android: package through plus
                    if( $framework || ($references_flags{$index} & $REF_INTERNAL) != 0 ) {
                        print STDERR "$package_name $package\n";
                        die "Reference 0x$2 refers once to $references{$index} and once to $package:$str";
                    }
                }

                if( exists $rev_references{"$package:$str"} ) {
                    printf STDERR "Symbol 0x%08x has the same name as 0x%08x: $package:$str\n",
                           $index, $rev_references{"$package:$str"};

                    # Search for a free name to use
                    my( $ext, $i )=("___COPY", 1);
                    while( exists $rev_references{"$package:$str$ext$i"} ) {
                        ++$i;
                    }

                    $str="$str$ext$i";
                    $flags|=$REF_RENAMED|$REF_DUPLICATE;
                }

                $references{$index}="$package:$str";
                $rev_references{"$package:$str"}=$index;

                $references_flags{$index}=$flags;
            } elsif( m"(spec )?resource 0x([0-9a-f]{8}) ([-a-zA-Z\.]+):([^:/]+)/([^:]+): <bag>( \(PUBLIC\))?" )
            {
                ($index, $package, $type, $str)=( hex($2), $3, $4, $5 );

                if( $1 ) {
                    $flags|=$REF_SPEC;
                }

                if( $6 ) {
                    $flags|=$REF_PUBLIC;
                }

                if( $type eq "attr" ) {
                    # We don't care about style bags at this point
                    $state=1; # Start of bag
                    $bag_index = "$package:$str";
                }
            } else {
            }
        } elsif( $state == 1 ) {
            # Start of bag
            if( m'Parent=0x([0-9a-f]{8}), Count=(\d+)' ) {
                die "Attrib style with parent 0x$1" if hex($1)!=0;
                $state = 2; # Cleanly inside the bag
                $counter = $2+0;
                $bag = { };
                $bag_flags = {};

                die "Zero counter on bag 0x$1" if $counter==0;
            } else {
                die "Line \"$_\" inside bag";
                $state = 0;
            }
        } elsif( $state == 2 ) {
            # Inside bag
            if( m'#(\d+) \(Key=0x([0-9a-f]{8})\): \(color\) #([0-9a-f]{8})' ) {
                if( exists $attrib_references{hex($2)} ) {
                    # Hardcoded reference
                    $bag->{$attrib_references{hex($2)}}=hex($3);
                } else {
                    $$bag_flags{hex($2)}=hex($3);
                }

                $counter--;
            } else {
                die "Inside bag, got unparsable \"$_\"" if( $counter>0 );
            }

            if( $counter == 0 ) {
                $state = 0;
                if( scalar keys %$bag_flags ) {
                    $bag->{flags}=$bag_flags;
                }
                $attrib_bags{$bag_index} = $bag;
            }
        }
    }

    close RESFILE;

    return 1;
}

sub set_package_name
{
    my ($apkpath)=@_;
    if( !open XMLFILE, "-|", "aapt", ("d", "xmltree", $apkpath, "AndroidManifest.xml") ) {
        print STDERR "Failed to dump XML tree $filename\n";
        return 0;
    }

    while(<XMLFILE>) {
        chomp;

        if( m'^    A: package="(.*)" \(Raw: ".*"\)$' ) {
            $flag = 0;

            $apk_package_name = $1;
            last;
        }
    }

    close XMLFILE;
}

sub xml_decompile
{
    my( $apkpath, $filename, $outdir ) = @_;
    my $error;

    print STDOUT "  Generating $filename\n";

    make_path( dirname("$outdir/$filename"), { error => \$error } );
    if( @$error ) {
        print STDERR "Error creating ".dirname("$outdir/$filename").": $!\n";

        return 0;
    }

    if( !open XMLFILE, "-|", "aapt", ("d", "xmltree", $apkpath, $filename) ) {
        print STDERR "Failed to dump XML tree $filename\n";
        return 0;
    }
    if( ! open OUTFILE, ">", "$outdir/$filename" ) {
        print STDERR "Failed to create XML file $outdir/$filename: $!\n";

        close XMLFILE;
        return 0;
    }

    print OUTFILE '<?xml version="1.0" encoding="utf-8"?>'."\n";
    my @elements=();
    my @schemas;
    my %namespaces, %rev_namespaces;
    my $current_level=-1;
    my $element_open=0;
    my $line_number=0;

    while(<XMLFILE>) {
        chomp;
        $line_number++;

        given ($_) {
            when(m'^( *)N: ([^=]+)=(http://schemas.android.com/apk/res/)(.*)$') {
                $namespaces{$2}=$4;
                $rev_namespaces{$4}=$2;
                local $new_level=length $1;
                $new_level/=2;
                local $firstline=1;
                while( $current_level>=$new_level ) {
                    # Close all pending open Elements
                    if( $elements[$current_level] ) {
                        print OUTFILE " "x($current_level*2) if !$firstline;

                        if( $element_open ) {
                            print OUTFILE " />\n";
                            $element_open=0;
                        } else {
                            print OUTFILE "</$elements[$current_level]>\n";
                        }
                        $firstline=0;
                    }
                    --$current_level;
                }

                if( $element_open ) {
                    # Close pending elements
                    print OUTFILE ">\n";
                    $element_open=0;
                }

                $new_level<=$current_level+1 or
                        die("Jumped for level $current_level to $new_level in one go at $filename:$line_number");
                $current_level=$new_level;
                $elements[$new_level]="";
                push( @schemas, "xmlns:$2=\"$3$4\"");
            }
            when(m'^( *)N: ([^=]+)=(.*)$') {
                $namespaces{$2}=$3;
                $rev_namespaces{$3}=$2;
                local $new_level=length $1;
                $new_level/=2;
                local $firstline=1;
                while( $current_level>=$new_level ) {
                    # Close all pending open Elements
                    if( $elements[$current_level] ) {
                        print OUTFILE " "x($current_level*2) if !$firstline;

                        if( $element_open ) {
                            print OUTFILE " />\n";
                            $element_open=0;
                        } else {
                            print OUTFILE "</$elements[$current_level]>\n";
                        }
                        $firstline=0;
                    }
                    --$current_level;
                }

                if( $element_open ) {
                    # Close pending elements
                    print OUTFILE ">\n";
                    $element_open=0;
                }

                $new_level<=$current_level+1 or
                        die("Jumped for level $current_level to $new_level in one go at $filename:$line_number");
                $current_level=$new_level;
                $elements[$new_level]="";
                push( @schemas, "xmlns:$2=\"$3\"");
            }
            when(/^( *)E: ([^ ]+)/) {
                # Element
                local $new_level=length $1;
                $new_level/=2;
                local $firstline=1;
                while( $current_level>=$new_level ) {
                    # Close all pending open Elements
                    if( $elements[$current_level] ) {
                        print OUTFILE " "x($current_level*2) if !$firstline;

                        if( $element_open ) {
                            print OUTFILE " />\n";
                            $element_open=0;
                        } else {
                            print OUTFILE "</$elements[$current_level]>\n";
                        }
                        $firstline=0;
                    }
                    --$current_level;
                }
                $nospace=0;

                if( $element_open ) {
                    # Close pending elements
                    print OUTFILE ">\n";
                    $element_open=0;
                }

                $new_level<=$current_level+1 or 
                        die("Jumped for level $current_level to $new_level in one go at $filename:$line_number");

                $current_level=$new_level;
                $elements[$current_level]=$2;
                print OUTFILE "$1<$2";
                for( @schemas ) {
                    print OUTFILE " $_";
                }
                @schemas=(); # Empty the array
                        $element_open=1;
            }
            when(m'^( *)A: (([^:/]+):)?([^)]+)(\(0x[0-9a-f]+\))?=(.*)$') {
                # An attribute - we need to parse to find out which
                # Attribute with value
                $element_open or die "Attribute with no open element at $filename:$line_number";

                my ($indent, $attr, $val)=($1, $4, $6);
                if( $2 ) {
                    die "Attribute from undeclared namespace $3: \"$_\""
                            if ! exists $namespaces{$3};
                    $attr="$3:$4";
                    $val=parse_attribute($6, "$namespaces{$3}:$4", 1);
                } elsif( $val=~'^@0x([0-9a-f]+)( .*)$' ) {
                    $val="@".format_reference(hex($1));
                } elsif( $val=~'^\?0x([0-9a-f]+)( .*)$' ) {
                    $val="?".format_xml_styleref(hex($1), \%rev_namespaces);
                } elsif( $val=~'\(Raw: "(.*)"\)$' ) {
                    $val=escape_string($1, 1);
                } else {
                    die "Unparsable attribute";
                }

                print OUTFILE "\n$indent  $attr=\"$val\"";
            }
            when(/^( *)C: "(.*)"$/) {
                # Tag content
                $element_open or die "Content with no open element at $filename:$line_number";

                # Unescape the string, and escape it differently
                my $content=$2;
                $content=~s/\\n/\n/g;
                $content=~s/\\t/\t/g;
                $content=~s/\\\\/\\/g;
                $content=~s/&/&amp;/g;

                print OUTFILE ">$content";
                $element_open=0;
                $nospace=1;
            }
            when(/^Adding resources to ResTable:/) {
                # Administrative messages
            }
            default {
                die "Unknown line at $filename:$line_number: \"$_\"";
            }
        }
    }

    if( $element_open ) {
        # Close pending elements
        print OUTFILE ">\n";
        $element_open=0;
    }
    while( $current_level>=0 ) {
        # Close all pending open Elements
        if( $elements[$current_level] ) {
            print OUTFILE " "x($current_level*2) if !$nospace;
            $nospace=0;
            print OUTFILE "</$elements[$current_level]>\n";
        }
        --$current_level;
    }

    close XMLFILE;
    close OUTFILE;

    return 1;
}

sub num_set_bits
{
    my ($val)=@_;
    my $ret=0, $i=0;

    # Use a translation table for each nibble. There are 8 nibbles in 32 bit
    while( $i<8 && $val!=0 ) {
        $ret+=$bitcount[$val&0x0f];
        $val>>=4;
        $i++;
    }

    return $ret;
}

sub reparse_attrib
{
    my ( $attrib, $val ) = @_;
    $val = $val * 1;

    # Is there anything to translate?
    if( !exists( $attrib_bags{$attrib} ) ) {
        return undef;
    }

    my $bag = $attrib_bags{$attrib};
    die "Attrib $attrib with no format" if ! exists $bag->{format};

    my $ret=undef;
    my $bag_flags=$bag->{format};
    if( ($bag_flags&0x00030000) != 0 ) {
        die "Attrib $attrib should have flags, but doesn't" if ! exists $bag->{flags};

        # Attrib has either enum or flags, either way this code will handle it
        $ret=reparse_attrib_enum_flags($bag->{flags}, $attrib, $val);

        $bag_flags&= ~0x00030000;
    }

    return $ret if defined $ret;

    if( $bag_flags & 0x0004 ) {
        # Integer is one of the accepted types
        return sprintf "%d", $val;
    }

    my $strval=sprintf "%08x", $val;
    for( keys %attrib_types ) {
        if( ($_ & 0xfff8) ) {
            if( ($bag_flags&$_)!=0 ) {
                $ret = format_value( $strval, ${$attrib_types{$_}}[1] );

                $bag_flags &= ~$_;
            }
        }
    }

    die sprintf "Unhandled flags in bag $attrib 0x%08x", $bag_flags
            if $bag_flags!=0 && ! defined $ret;
    die sprintf "Failed to format attrib $attrib with value #%08x", $val
            if ! defined $ret;

    return $ret;
}

sub reparse_attrib_enum_flags
{
    my ($bag, $attrib, $val)=@_;

    my ($ret, $data, $zero )=(undef, 0, undef);
    my $rev = ~$val;
    my @selected;
    my @bag_keys=keys( %$bag );

    @bag_keys = sort { num_set_bits($bag->{$b}) <=> num_set_bits($bag->{$a}) } @bag_keys;

    for( @bag_keys ) {
        if( ($rev & $bag->{$_})==0 ) {
            die sprintf "Attrib $attrib contains key 0x%08x which is undefined"
                    if ! exists( $references{$_} );
            if( ($data | $bag->{$_}) != $data ) {
                $data |= $bag->{$_};
                push @selected, $_;
            } elsif( $bag->{$_}==0 ) {
                $references{$_} =~ '/(.*)$';
                $zero = $1;
            }
        }

        last if( $data!=0 && $data==$val ); # We are done anyways
    }

    return $zero if $val==0 && $zero;
    return undef if $val!=$data || $#selected==-1;

    # We now need to eliminate overlapping values
    $val=0;
    while( $#selected > -1 ) {
        my $att = shift @selected;
        my $att_val=$bag->{$att};
        my $flag=0;

        # This value is not contained by any values that came before, but it might be contained
        # by values later on.
        FUTURE: for( @selected ) {
            # Does the current attribute change the $i attribute?
            if( ($bag->{$_}|$att_val|$val)==($bag->{$_}|$val) ) {
                $flag=1;
                last FUTURE;
            }
        }

        if( !$flag ) {
            $references{$att} =~ '/(.*)$';
            $ret .= "|" if length($ret)>0;
            $ret .= $1;
            $val |= $att_val;
        }
    }

    die sprintf("Internal logic error val=#%08x data=#%08x", $val, $data) if $val != $data;

    return $ret;
}

# Parse a floating point type
sub parse_type_4
{
    my $val=hex($_[0]);
    my $value=0.0;

    # Zero is a special case in FP
    if( $val!=0 ) {
        # 1 bit of sign, 8 bits of exponent, 23 bits of mantissa
        my $man=$val % 0x800000;
        $man/=2**23;
        $man+=1;

        $val>>=23;

        my $exp=$val % 0x100;
        $exp-=0x7f;
        $val>>=8;

        $value=$man*2**$exp;

        if( $val ) {
            $value= -$value;
        }
    }

    return $value;
}

# Parse a dimension type
sub parse_type_5
{
    my $val=signedhex($_[0]);

    # Extract the value type
    my $value=$val/256;
    $value+=0.5;
    $value=floor($value);
    my $unit;

    # Check which unit to use
    given( $val & 0x0f ) {
        when(0) { $unit='px'; }
        when(1) { $unit='dip'; }
        when(2) { $unit='sp'; }
        when(3) { $unit='pt'; }
        when(4) { $unit='in'; }
        when(5) { $unit='mm'; }
        default { die "$filename:$line_number: Unknown unit for type: \"$_[0]\"\n"; }
    }

    # Check what split between fraction and whole
    given( ($val & 0x30)>>4 ) {
        when(0) { };                        # Integer
        when(1) { $value/=128 };            # Fix point 7 bit shift
        when(2) { $value/=32768 };          # Fix point 15 bit shift
        when(3) { $value/=8,388,608 };      # Fix point 23 bit shift
    }

    return "$value$unit";
}

# Parse fraction type
sub parse_type_6
{
    my $val=signedhex($_[0]);

    # 4 bit relation
    my $relation=$val&0x7;
    $val >>= 4;
    # 4 bit fraction type
    my $type=$val&0x7;
    $val >>= 4;

    # 23 bit mantissa
    my $mantissa=$val&((1<<23)-1);
    $val >>= 23;

    # $val is zero if the number is positive
    if( $val ) {
        # Number is negative - perform two's complement on it to turn it positive
        $mantissa ^= (1<<23)-1;
        $mantissa ++;
        $val="-";
    } else {
        $val="";
    }

    given( $type ) {
        when( 0x0 ) {
            # Number is whole - do nothing
        }
        when( 0x1 ) {
            # 16 bit whole, 7 bit fraction
            $mantissa /= 2.0 ** 7;
        }
        when( 0x2 ) {
            # 8 bit whole, 15 bit fraction
            $mantissa /= 2.0 ** 15;
        }
        when( 0x3 ) {
            # 23 bits of fraction
            $mantissa /= 2.0 ** 23;
        }
        default {
            die "While parsing fraction type, unknown type $type";
        }
    }

    $mantissa *= 100; # Turn it into percents

    given( $relation ) {
        when( 0 ) {
            $relation="";
        }
        when( 1 ) {
            $relation="p";
        }
        default {
            die "While parsing fraction type, unknown relation $relation at $filename:$line_number";
        }
    }

    return "$val$mantissa%$relation";
}

# Parse type boolean
sub parse_type_12
{
    my $val=signedhex($_[0]);

    if( $val==0 ) {
        return "false";
    } elsif( $val==-1 ) {
        return "true";
    } else {
        die sprintf "Boolean is 0x%08x, neither 0 nor -1", $val;
    }
}

# Parse type ARGB8
sub parse_type_1c
{
    my $val=hex($_[0]);

    return sprintf "#%08x", $val;
}

# Parse type RGB8
sub parse_type_1d
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    $val&=0x00ffffff;

    return sprintf "#%06x", $val;
}

# Parse type ARGB4
sub parse_type_1e
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    my $value=0;

    $val>>=4;
    $value=$val&0xf;

    $val>>=4;
    $value|=$val&0xf0;

    $val>>=4;
    $value|=$val&0xf00;

    $val>>=4;
    $value|=$val&0xf000;

    return sprintf "#%04x", $value;
}

# Parse type RGB4
sub parse_type_1f
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    my $value=0;

    $val>>=4;
    $value=$val&0xf;

    $val>>=4;
    $value|=$val&0xf0;

    $val>>=4;
    $value|=$val&0xf00;

    return sprintf "#%03x", $value;
}

sub parse_attribute
{
    my ($value, $attrib, $known_string)=@_;

    given( $value ) {
        when(/^.*\(Raw: "(.*)"\)$/) {
            return escape_string($1, $known_string);
        }
        when(/^\(type 0x4\)0x(.*)$/) {
            return parse_type_4($1);
        }
        when(/^\(type 0x5\)0x(.*)$/) {
            return parse_type_5($1);
        }
        when(/^\(type 0x6\)0x(.*)$/) {
            return parse_type_6($1);
        }
        when(/^\(type 0x10\)0x(.*)$/) {
            my $val=reparse_attrib( $attrib, hex($1) );

            if( !defined($val) ) {
                $val=signedhex($1);
            }

            return $val;
        }
        when(/^\(type 0x11\)0x(.*)$/) {
            my $val=reparse_attrib( $attrib, hex($1) );

            if( !defined($val) ) {
                $val=sprintf "0x%x", hex($1);
            }

            return $val;
        }
        when(/^\(type 0x12\)0x(.*)$/) {
            return parse_type_12($1);
        }
        when(/^\(type 0x1c\)0x(.*)$/) {
            return parse_type_1c($1);
        }
        when(/^\(type 0x1d\)0x(.*)$/) {
            return parse_type_1d($1);
        }
        when(/^\(type 0x1e\)0x(.*)$/) {
            return parse_type_1e($1);
        }
        when(/^\(type 0x1f\)0x(.*)$/) {
            return parse_type_1f($1);
        }
        when(/^\@0x([0-9a-f]+)$/) {
            # Resource reference
            my $res=hex($1);

            return "@".format_reference($res);
        }
        when(/^\?0x([0-9a-f]+)$/) {
            # Theme reference
            exists( $references{hex($1)} ) or 
                    die "Attribute points to theme resource 0x$1 which doesn't exist";

            return "?$references{hex($1)}";
        }
        default {
            die "Unparsable line \"$_\"";
        }
    }
}

# Convert all 32 bit values to signed 32 bit, regardless of whether our perl implementation is 32
# or 64 bit.
sub make_signed {
    local $ret=shift(@_)+0;

    if ($ret>=0x80000000) {
        $ret-=0x100000000;
    }

    return $ret;
}
sub signedhex {
    local $ret=hex(shift(@_));

    return make_signed($ret);
}

sub printhash {
    my ($hash) = @_;

    my $ret="{ ";
    for ( keys( %$hash ) ) {
        $ret .= $_."=>".$$hash{$_}." ";
    }

    $ret.="}";

    return $ret;
}

sub dump_values
{
    my ( $apkpath, $outdir )=@_;

    if( ! open RESOURCES, "-|", "aapt", ( "d", "--values", "resources", $apkpath) ) {
        print STDERR "Failed to dump resources from $apkpath: $!\n";

        return 1;
    }

    my $state=0;
    my $configname=undef;
    my ($class, $name, $type, $index);
    my $error;

    while( <RESOURCES> ) {
        chomp;
        
        if( m'Package Group \d+ id=\d+ packageCount=\d+ name=(.+)$' ) {
            $package_name=$1;

            $package_ext = $package_name eq $apk_package_name ? "" : ".$1";
        } elsif( m'^ *config (\d+)( .*)?$' ) {
            # Start of new configuration block
            close_pending_files(); # Close all open pending files
            $configname=parse_config_name($2);
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):([^/]+)/([^:]+): t=0x([0-9a-f]+)' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference: $2:$3/$4 ne $references{hex($1)}"
                    if $references{hex($1)} ne "$2:$3/$4";
            ($class, $name, $type, $index)=( $3, $4, $5, hex($1) );
            $state = 1;
        } elsif( defined $name && $state==1 ) {
            if( !parse_values( $index, $class, $name, $type, $_, $outdir, $configname ) ) {
                return 1;
            }

            ($class, $name, $type)=(undef, undef, undef);
            $state=0;
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):array/([^:]+): <bag>( \(PUBLIC\))?$' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:array/$3";

            $class="array";
            $name=$3;
            $state=2;
            $references_flags{hex($1)} |= $REF_USED;
        } elsif( $state==2 ) {
            m'^ *Parent=0x([0-9a-f]+), Count=(\d+)$' or
                    die "Unexpected text \"$_\" after array start";
            die "Non-zero parent for array \"$_\"" if hex($1)!=0;

            $count=$2+0; # Make sure perl knows it is, indeed, an integer
            $state=3;

            write_array_open($name, $outdir, $configname);

            if( $count==0 ) {
                write_array_close($name);
                $state=0;
            }
        } elsif( $state==3 ) {
            m'^ *#(\d+) \(Key=0x[0-9a-f]+\): (.*)$' or
                    die "Unexpected text \"$_\" for array item";

            write_array_item($2);

            if( --$count == 0 ) {
                write_array_close($name);
                $state=0;
            }
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):attr/([^:]+): <bag>' && 0 ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference. Was $references{hex($1)} now $2:attr/$3"
                    if $references{hex($1)} ne "$2:attr/$3";

            $class="attr";
            $name=$3;
            $state=4;
            $references_flags{hex($1)} |= $REF_USED;
        } elsif( $state==4 ) {
            m'^ *Parent=0x([0-9a-f]+), Count=(\d+)$' or
                    die "Unexpected text \"$_\" after attr start";
            die "Non-zero parent for attribute \"$_\"" if hex($1)!=0;

            $count=$2+0; # Make sure perl knows it is, indeed, an integer
            die "Attribute with count different than 1" if $count!=1;

            $state++;

            if( $count==0 ) {
                $state=0;
            }
        } elsif( $state==4 ) {
            m'^ *#(\d+) \(Key=0x[0-9a-f]+\): \(color\) #(.*)$' or
                    die "Unexpected text \"$_\" for attr item";

            write_attr($name, hex($2));

            if( --$count == 0 ) {
                $state=0;
            }
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):style/([^:]+): <bag>( \(PUBLIC\))?$' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:style/$3";

            $class="style";
            $name=$3;
            $state=30;
            $references_flags{hex($1)} |= $REF_USED;
        } elsif( $state==30 ) {
            m'^ *Parent=0x([0-9a-f]+), Count=(\d+)$' or
                    die "Unexpected text \"$_\" after array start";
            $count=$2+0; # Make sure perl knows it is, indeed, an integer
            $state=31;

            write_style_open($name, $outdir, $configname, hex($1));

            if( $count==0 ) {
                write_style_close($name);
                $state=0;
            }
        } elsif( $state==31 ) {
            m'^ *#(\d+) \(Key=0x([0-9a-f]+)\): (.*)$' or
                    die "Unexpected text \"$_\" for style item";

            write_style_item($3, hex($2));

            if( --$count == 0 ) {
                write_style_close($name);
                $state=0;
            }
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):plurals/([^:]+): <bag>$' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:plurals/$3";

            $class="plurals";
            $name=$3;
            $state=40;
            $references_flags{hex($1)} |= $REF_USED;
        } elsif( $state==40 ) {
            m'^ *Parent=0x([0-9a-f]+), Count=(\d+)$' or
                    die "Unexpected text \"$_\" after array start";
            die "Plurals $name with non-empty parent" if hex($1)!=0;

            $count=$2+0; # Make sure perl knows it is, indeed, an integer
            $state=41;

            write_plurals_open($name, $outdir, $configname);

            if( $count==0 ) {
                write_plurals_close($name);
                $state=0;
            }
        } elsif( $state==41 ) {
            m'^ *#(\d+) \(Key=0x([0-9a-f]+)\): (.*)$' or
                    die "Unexpected text \"$_\" for plurals item";

            write_plurals_item($3, hex($2));

            if( --$count == 0 ) {
                write_plurals_close($name);
                $state=0;
            }
        } else {
            # XXX print "Unmatched: $_\n";
        }
    }

    die "Ended while still inside bag state=$state" if $state!=0;

    close( RESOURCES );

    dump_attributes($outdir);

    close_pending_files();

    return write_public_file($outdir);
}

sub parse_config_name
{
    my ($string)=@_;

    my $ret="";

    # The order here is important! See http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources

    if( $string=~/mcc=(\d+)/ ) {
        # MCC code
        $ret.="-mcc$1";
    }
    if( $string=~/mnc=(\d+)/ ) {
        # MNC code, must come after MCC
        $ret.="-mnc$1";
    }
    if( $string=~/lang=([a-z]+)/ ) {
        # Language
        $ret.="-$1";
    }
    if( $string=~/swdp=([0-9]+)/ ) {
        # Smallest Width
        $ret.="-sw$1dp";
    }
    if( $string=~/wdp=([0-9]+)/ ) {
        # Available width
        $ret.="-w$1dp";
    }
    if( $string=~/hdp=([0-9]+)/ ) {
        # Available height
        $ret.="-h$1dp";
    }
    if( $string=~/cnt=([A-Z]+)/ ) {
        # Country, must come after language
        $ret.="-r$1";
    }
    if( $string=~/sz=(\d+) \((\S+)\)/ ) {
        # Screen size
        $ret.="-$2";
    }
    if( $string=~/lng=(\d+) \((\S+)\)/ ) {
        # Long vs. Normal screen
        $ret.="-$2";
    }
    if( $string=~/orient=(\d+) \((\S+)\)/ ) {
        # Screen orientation
        $ret.="-$2";
    }
    if( $string=~/type=(\d+) \((\S+)\)/ ) {
        # Type - car or desk
        $ret.="-$2";
    }
    if( $string=~/night=(\d+) \((\S+)\)/ ) {
        # Daytime - night vs. day (notnight)
        $ret.="-$2";
    }
    if( $string=~/density=(\S+)/ ) {
        # Screen pixel density
        if( $1==120 ) {
            $ret.="-ldpi";
        } elsif( $1==160 ) {
            $ret.="-mdpi";
        } elsif( $1==240 ) {
            $ret.="-hdpi";
        } elsif( $1==320 ) {
            $ret.="-xhdpi";
        } elsif( $1 eq "no" ) {
            $ret.="-nodpi";
        } else {
            die "Unsupported density mode $1: $string";
        }
    }
    if( $string=~/touch=(\d+) \((\S+)\)/ ) {
        # Touch vs. Stylus
        $ret.="-$2";
    }
    if( $string=~/keyhid=(\d+) \((\S+)\)/ ) {
        # Keyboard availability
        if( $1==1 ) {
            $ret.="-keysexposed";
        } elsif( $1==2 ) {
            $ret.="-keyshidden";
        } elsif( $1==3 ) {
            $ret.="-keyssoft";
        } else {
            die "Key status $1($2) unknown";
        }
    }
    if( $string=~/kbd=(\d+) \((\S+)\)/ ) {
        # Primary input method
        $ret.="-$2";
    }
    if( $string=~/navhid=(\d+) \((\S+)\)/ ) {
        # Navigation keys status
        if( $1==4 ) {
            $ret.="-navexposed";
        } elsif( $1==8 ) {
            $ret.="-navhidden";
        } else {
            die "Unsupported navigation availability value $1: $string";
        }
    }
    if( $string=~/nav=(\d+) \((\S+)\)/ ) {
        # Primary non-touch navigation method
        $ret.="-$2";
    }
    if( $string=~/w=(\d+) h=(\d+)/ ) {
        # Dropped from the documentation as if it never existed:
        # Screen width and height
        $ret.="-$1x$2";
    }
    if( $string=~/sdk=(\d+)/ ) {
        # XXX Might add code to not print if minimal version dictated by other attributes
        # Minimal SDK version
        $ret.="-v$1";
    }

    return $ret;
}

sub open_config_file
{
    my( $class, $outdir, $configname, $filename )=@_;
    return $type_files{$class} if exists $type_files{$class};

    make_path( "$outdir/res/values$configname", { error => \$error } );
    my $fileref;
    if( !defined $filename ) {
        $filename="${class}s";
    }

    $filename = "$filename$package_ext";

    if( -f "$outdir/res/values$configname/${filename}.xml" ) {
        # More than one config with the same modifiers defined the same class
        print STDERR "Redundant configuration of values$configname/${filename}.xml. Creating copy.\n";
        $filename=".$filename";

        my $count=1;
        while( -f "$outdir/res/values$configname/${filename}.$count.xml" ) {
            $count++;
        }

        $filename="$filename.$count";
    }

    open $fileref, ">$outdir/res/values$configname/${filename}.xml" or
            die "Failed to open res/values$configname/${filename}.xml: $!";

    print $fileref '<?xml version="1.0" encoding="utf-8"?>'."\n";
    print $fileref "<resources>\n";

    $type_files{$class}=$fileref;

    return $type_files{$class};
}

sub close_pending_files
{
    for( keys %type_files ) {
        my $fileref = $type_files{$_};
        print $fileref "</resources>\n";
        close $fileref;

        delete $type_files{$_};
    }
}

sub parse_values
{
    my( $index, $class, $name, $type, $string, $outdir, $configname )=@_;

    if( ! exists $class_map{$class} ) {
        print STDERR "Project defines non-standard class \"$class\"\n";
        $class_map{$class}=\&parse_unknown_value;
    }

    $references_flags{$index} |= $REF_USED;
    if( defined $class_map{$class} ) {
        my $fileref = open_config_file( $class, $outdir, $configname );

        ${class_map{$class}}( $name, $type, $string, $class );
    }

    return 1;
}

sub parse_unknown_value
{
    my( $name, $type, $string, $class )=@_;

    $type=hex($type);
    my $fileref = $type_files{$class};
    print $fileref "  <item type=\"$class\" name=\"$name\">".format_value($string, $type).
            "</item>\n";
}

sub parse_id_value
{
    my( $name, $type, $string, $class )=@_;

    $type=hex($type);
    my $fileref = $type_files{id};
    print $fileref "  <item type=\"id\" name=\"$name\">".format_value($string, $type)."</item>\n";
}

sub parse_bool_value
{
    my( $name, $type, $string, $class )=@_;

    if( $string!~'^\s*\(color\) #(\S+)$' ) {
        die "Invalid boolean format: \"$string\"";
    }

    $type=hex($type);
    my $fileref = $type_files{bool};
    print $fileref "  <bool name=\"$name\">".format_value($1, $type)."</bool>\n";
}

sub parse_int_value
{
    my( $name, $type, $string, $class )=@_;

    if( $string!~'^\s*\(color\) #(\S+)$' ) {
        die "Invalid integer format: \"$string\"";
    }

    my $fileref = $type_files{integer};
    printf $fileref "  <integer name=\"$name\">%d</integer>\n", signedhex($1);
}

sub parse_fraction_value
{
    my( $name, $type, $string, $class )=@_;

    if( $string!~'^\s*\(fraction\) (\S+)%$' ) {
        die "Invalid fraction format: $name $type $class \"$string\"";
    }

    my $fileref = $type_files{fraction};
    printf $fileref "  <$class name=\"$name\">%f%%</$class>\n", $1;
}

# Accept a string as reported by aapt, and issue it in a form suitable for XML output
sub escape_string
{
    my($string,$known_string)=@_;

    $string=~s/&/&amp;/g;
    $string=~s/</&lt;/g;
    $string=~s/>/&gt;/g;
    $string=~s/"/u0022/g;
    $string=~s/\t/\\t/g;
    # $string=~s/ /\\u0020/g;
    $string=~s/\N{U+200e}/\\u200e/g; # LRM
    $string=~s/\N{U+200f}/\\u200f/g; # RLM
    $string=~s/^@/\\@/g;
    $string=~s/^\?/\\?/g;

    if( ! $known_string ) {
        return '"'.$string.'"';
    } else {
        return $string;
    }
}

sub parse_string_value
{
    my( $name, $type, $string, $class )=@_;
    my $fileref = $type_files{string};

    $type=hex($type);
    if( $type==3 ) {
        # Direct UTF-8 string
        if( $string!~'^\s*\(string8\) "(.*)"$' &&
                $string!~'^\s*\(string16\) "(.*)"$' )
        {
            die "Invalid string format: \"$string\"";
        }
        print $fileref "  <string name=\"$name\" formatted=\"false\" >".escape_string($1).
                "</string>\n";
    } elsif( $type==1 ) {
        if( $string!~'^\s*\(reference\) 0x([0-9a-f]+)$' ) {
            die "Invalid string format: \"$string\"";
        }

        die "Invalid reference 0x$1" if !exists $references{hex($1)};

        print $fileref "  <string name=\"$name\">@".$references{hex($1)}."</string>\n";
    } else {
        die "Unhandled string type $type: \"$string\"";
    }
}

sub parse_dimen_value
{
    my( $name, $type, $string, $class )=@_;

    my $fileref = $type_files{dimen};

    if( $type==5 ) {
        # Processed dimension
        if( $string!~'^\s*\(dimension\) (\S+)$' ) {
            die "Invalid dimension format: \"$string\"";
        }
        print $fileref "  <dimen name=\"$name\">$1</dimen>\n";
    } elsif( $type==6 ) {
        if( $string!~'^\s*\(fraction\) (\S+)%$' ) {
            die "Invalid fraction format: \"$string\"";
        }
        printf $fileref "  <item type=\"dimen\" name=\"$name\">%f%%</item>\n", $1*100;
    } else {
        die "Unhandled dimen type $type: \"$string\"";
    }
}

sub parse_color_value
{
    my( $name, $type, $string, $class )=@_;

    my $fileref = $type_files{$class};

    $type = hex($type);
    if( $type==0x1f || $type==0x1c || $type==0x1d || $type==0x1e ) {
        # Processed color
        if( $string!~'^\s*\(color\) #(\S+)$' ) {
            die "Invalid string format: \"$string\"";
        }
        print $fileref "  <$class name=\"$name\">".format_value($1, $type)."</$class>\n";
    } elsif( $type==3 ) {
        # Do nothing. Reference to external XML
    } elsif( $type==1 ) {
        if( $string!~'^\s*\(reference\) 0x([0-9a-f]+)$' ) {
            die "Invalid reference format: \"$string\"";
        }

        die "Invalid reference 0x$1" if !exists $references{hex($1)};

        print $fileref "  <$class name=\"$name\">@".$references{hex($1)}."</$class>\n";
    } else {
        die "Unhandled color type $type: \"$string\"";
    }
}

sub write_array_open
{
    my($name, $outdir, $configname)=@_;

    my $fileref = open_config_file( "array", $outdir, $configname );

    print $fileref "  <array name=\"$name\">\n"
}

sub write_array_item
{
    my($string)=@_;

    my $fileref = $type_files{array};

    my($value,,$comment)=parse_content($string);

    if( $comment eq "" ) {
        print $fileref "    <item>$value</item>\n";
    } else {
        print $fileref "    <item>$value</item> <!-- $comment -->\n";
    }
}

sub write_array_close
{
    my($name)=@_;

    my $fileref = $type_files{array};

    print $fileref "  </array>\n\n"
}

sub write_attr
{
    my ($name, $type)=@_;
}

sub write_style_open
{
    my($name, $outdir, $configname, $parent)=@_;

    die sprintf("Parent 0x%08x does not exist", $parent)
            if !exists $references{$parent};

    my $fileref = open_config_file( "style", $outdir, $configname );

    if( $parent==0 ) {
        print $fileref "  <style name=\"$name\">\n";
    } else {
        print $fileref "  <style name=\"$name\" parent=\"@".format_reference($parent)."\">\n";
    }
}

sub write_style_item
{
    my($string, $nameref)=@_;

    die sprintf( "Key references non-existing resource 0x%08x", $nameref )
            if ! exists $references{$nameref};

    my $fileref = $type_files{style};
    my($value,$type,$comment)=parse_content($string);

    print $fileref "    <item";
    if($nameref!=0)
    {
        $references{$nameref}=~'^([^:/]+):([^:/]+)/([^:/]+)$' or
                    die "Invalid reference format $references{$nameref}";

        my ($package, $class, $name)=($1, $2, $3);
        die "Not an attribute item name \"$references{$nameref}\"" if( $class ne "attr" );

        print $fileref " name=\"$package:$name\"";

        if( $type eq "color" ) {
            # This might be a bit field/enum
            $value=~/^#(.*)$/ or die "Color $value with invalid format";

            my $tmpval=reparse_attrib( "$package:$name", hex($1) );

            if( defined $tmpval ) {
                $value=$tmpval;
                $comment="";
            }
        }
    }
    print $fileref ">$value</item>";

    if($comment ne "" ) {
        print $fileref "  <!-- $comment -->";
    }

    print $fileref "\n";
}

sub write_style_close
{
    my($name)=@_;

    my $fileref = $type_files{style};

    print $fileref "  </style>\n\n";
}

sub write_plurals_open
{
    my($name, $outdir, $configname)=@_;

    my $fileref = open_config_file( "plural", $outdir, $configname );

    print $fileref "  <plurals name=\"$name\">\n";
}

sub write_plurals_item
{
    my($string, $nameref)=@_;

    die sprintf( "Plural references non-existing resource 0x%08x", $nameref )
            if ! exists $plural_references{$nameref};

    my $fileref = $type_files{plural};

    my($value,$type,$comment)=parse_content($string);
    $value = add_format_index( $value );
    print $fileref "    <item quantity=\"$plural_references{$nameref}\">$value</item>\n";
}

sub add_format_index
{
    my $ret=$_[0];

    # should we handle this at all?
    if( $ret!~/%[sd].*%[sd]/ || $ret=~/%\d+\$[sd]/ )
    {
        return $ret;
    }

    my $i=1;
    while( $ret=~/^(([^%]*%[^sd])*[^%]*)%([sd])(.*)$/ ) {
        $ret="$1%$i\$$3$4";
        ++$i;
    }

    return $ret;
}

sub write_plurals_close
{
    my($name)=@_;

    my $fileref = $type_files{plural};

    print $fileref "  </plurals>\n";
}

sub dump_attributes
{
    my ($outdir)=@_;

    my $fileref = open_config_file( "attr", $outdir, "", "attrs" );

    for( keys %attrib_bags ) {
        if( $_=~'^([^:/]+):([^:/]+)$' ) {
            if( $1 eq $apk_package_name ) {
                # Only handle the attribs that belong to this package
                my($key, $name)=($_, $2);

                # Mark the attribute as used
                $references_flags{$rev_references{"$1:attr/$2"}} |= $REF_USED;

                print $fileref "  <attr name=\"$name\"";

                my $bag=$attrib_bags{$key};

                die "Attribute $key does not have a format"
                        if ! exists $bag->{format};

                my $format=$bag->{format};

                # Do we have a scalar format?
                if( ($format&0xffff)!=0 ) {
                    my $format_string;
                    for( keys %attrib_types ) {
                        if( ($_&0xffff)!=0 && ($format&$_)!=0 ) {
                            $format_string.="|" if $format_string;
                            $format_string.=${$attrib_types{$_}}[0];
                        }
                    }
                    print $fileref " format=\"$format_string\"";
                }

                # Hard coding the types is not nice, but somewhat necessary
                if( exists $bag->{min} ) {
                    print $fileref " min=\"$bag->{min}\"";
                }
                if( exists $bag->{max} ) {
                    print $fileref " max=\"$bag->{max}\"";
                }
                if( exists $bag->{localization} ) {
                    die "Localization type present but is not 1 (is $bag->{localization}) in $key"
                            if $bag->{localization}!=1;
                    print $fileref " localization=\"suggested\"";
                }

                # Do we need content to this XML element?
                if( ($format&0xffff0000)==0 ) {
                    # Element is done
                    print $fileref " />\n";
                } else {
                    die "Attrib $key with content has no bag information"
                            if ! exists $bag->{flags};
                    my $bag_flags=$bag->{flags};
                    print $fileref ">\n";
                    if( $format&0x00010000 ) {
                        # Enum list
                        for( keys %$bag_flags ) {
                            die sprintf "Attrib $key has enum element 0x%08x with no name", $_
                                    if ! exists $references{$_};
                            $references{$_}=~'^([^:/]+):([^:/]+)/([^:/]+)$' or
                                    die "Attrib $key reference $references{$_} with bad format";
                            my ($package, $class, $name)=($1, $2, $3);
                            die "Attrib $key references $references{$_} which is not an id"
                                    if $class ne "id";
                            die "Attrib $key references $references{$_} which is not in package"
                                    if $package ne $apk_package_name;

                            $references_flags{$_} |= $REF_USED;
                            printf $fileref "    <enum name=\"$name\" value=\"%d\" />\n",
                                   make_signed($bag_flags->{$_});
                        }
                    } elsif( $format&0x00020000 ) {
                        # Flags list
                        for( keys %$bag_flags ) {
                            die sprintf "Attrib $key has enum element 0x%08x with no name", $_
                                    if ! exists $references{$_};
                            $references{$_}=~'^([^:/]+):([^:/]+)/([^:/]+)$' or
                                    die "Attrib $key reference $references{$_} with bad format";
                            my ($package, $class, $name)=($1, $2, $3);
                            die "Attrib $key references $references{$_} which is not an id"
                                    if $class ne "id";
                            die "Attrib $key references $references{$_} which is not in package"
                                    if $package ne $apk_package_name;

                            $references_flags{$_} |= $REF_USED;
                            printf $fileref "    <flag name=\"$name\" value=\"0x%x\" />\n",
                                    $bag_flags->{$_};
                        }
                    } else {
                        die "Unknown bag format for $key";
                    }

                    print $fileref "  </attr>\n";
                }
            }
        } else {
            die "Internal error in attrib bag $_";
        }
    }
}

# Return a list of parsed name, type and comment (if any)
sub parse_content
{
    my($string)=@_;
    my($ret, $type, $comment);

    given( $string ) {
        when( m'^\((reference)\) 0x([0-9a-f]+)$' ) {
            $type=$1;
            my $ref=hex($2);

            $ret="@".format_reference($ref);
        }
        when( m'^\((color)\) #([0-9a-f]+)$' ) {
            # We cannot tell a color from an integer
            $type=$1;
            $ret="#$2";
            $comment="or int ".signedhex($2);
        }
        when( m'^\((string8)\) "(.*)"$' ) {
            $type=$1;
            $ret=escape_string($2);
        }
        when( m'^\((string16)\) "(.*)"$' ) {
            $type=$1;
            $ret=escape_string($2);
        }
        when( m'^\((dimension)\) (.*)$' ) {
            $type=$1;
            $ret=$2;
        }
        when( m'^\((float)\) (.*)$' ) {
            $type=$1;
            $ret=$2;
        }
        when( m'^\((attribute)\) 0x(.*)$' ) {
            $type=$1;
            $ret="?".format_reference(hex($2));
        }
        default {
            die "Don't know how to parse \"$_\"";
        }
    }

    return($ret, $type, $comment);
}

sub write_public_file
{
    my($outdir)=@_;

    my $fileref = open_config_file( "public", $outdir, "", "public" );

    my @keys = sort keys %references;
    # Padding related values
    my ( $pad_start, $pad_end, $pad_base_name, $pad_class );

    for( @keys ) {
        my( $key, $value, $flags )=($_, $references{$_}, $references_flags{$_});

        if( $key!=0 ) {
            $value=~'([^:/]+):([^:/]+)/([^:/]+)' or die "Invalid reference value $value";
            my( $package, $class, $name )=($1, $2, $3);

            if( $package eq $package_name ) {
                # This is our reference

                if( ($flags&$REF_USED)!=0 ) {
                    # Emit cached padding, if any
                    if( defined $pad_start ) {
                        emit_public_padding( $fileref, $pad_start, $pad_end, $pad_base_name,
                                $pad_class );
                        $pad_start=undef;
                    }

                    printf $fileref "  <public type=\"%s\" id=\"0x%08x\" name=\"%s\" />\n",
                           $class, $key, $name;
                } else {
                    # This reference was never defined, needs to be padded.
                    if( defined $pad_start ) {
                        # We have previous padding cached. We need to either merge or emit and cache

                        $name =~ '^(.*[^0-9])([0-9]*)$';
                        if( $key==$pad_end+1 && $class eq $pad_class && $pad_base_name eq $1 ) {
                            # The entries match - combine them
                            $pad_end++;
                        } else {
                            emit_public_padding( $fileref, $pad_start, $pad_end, $pad_base_name,
                                    $pad_class );
                            $pad_start=undef;
                        }
                    }

                    if( ! defined $pad_start ) {
                        # Cache the entry for future use
                        $pad_start=$key;
                        $pad_end=$key;
                        $pad_class=$class;
                        $name =~ '^(.*[^0-9])([0-9]*)$';
                        $pad_base_name=$1;
                    }
                }
            }
        }
    }

    if( defined $pad_start ) {
        # We have previous padding cached. We need to emit

        emit_public_padding( $fileref, $pad_start, $pad_end, $pad_base_name, $pad_class );
    }

    close_pending_files();
}

sub emit_public_padding
{
    my ( $fileref, $start, $end, $name, $class )=@_;

    printf $fileref
            "  <public-padding type=\"%s\" start=\"0x%08x\" name=\"%s\" end=\"0x%08x\" />\n",
           $class, $start, $name, $end;
}

sub format_value
{
    my( $value, $type )=@_;

    if( $type==0x00 ) {
        # NULL
    } elsif( $type==0x01 ) {
        # Reference
        die "Type reference not yet supported \"$value\"";
    } elsif( $type==0x02 ) {
        # Attribute
        die "Type attribute not yet supported \"$value\"";
    } elsif( $type==0x03 ) {
        # String
        $value =~ '^\s*\(string(8|16)\) "(.*)"$' or die "Cannot parse \"$value\"";
        return escape_string($2);
    } elsif( $type==0x04 ) {
        # Float
        return parse_type_4($value);
    } elsif( $type==0x05 ) {
        # Dimension
        return parse_type_5($value);
    } elsif( $type==0x06 ) {
        # Fraction
        return parse_type_6($value);
    } elsif( $type==0x10 ) {
        # Decimal integer
        return signedhex($value);
    } elsif( $type==0x11 ) {
        # Hexadecimal integer
        return sprintf "0x%x", hex($1);
    } elsif( $type==0x12 ) {
        # Boolean
        return parse_type_12($value);
    } elsif( $type==0x1c ) {
        # ARGB8
        return parse_type_1c($value);
    } elsif( $type==0x1d ) {
        # RGB8
        return parse_type_1d($value);
    } elsif( $type==0x1e ) {
        # ARGB4
        return parse_type_1e($value);
    } elsif( $type==0x1f ) {
        # RGB4
        return parse_type_1f($value);
    } else {
        die sprintf("Unknown type %02x with value %s", $type, $value);
    }
}

sub format_reference
{
    my ($index)=@_;

    die sprintf "Reference 0x%08x is not defined", $index if ! exists $references{$index};

    # Handle NULL first off
    return $references{$index} if $index==0;

    $references{$index}=~'^([^:/]+):([^:/]+)/([^:/]+)$' or die "Invalid reference format \"$references{$index}\"";
    my ( $package, $class, $name ) = ( $1, $2, $3 );

    my $ret="$class/$name";

    # Add package name for external references
    if( $package ne $apk_package_name ) {
        $ret="$package:$ret";

        if( ($references_flags{$index} & $REF_INTERNAL)!=0 ) {
            # Add plus for references that need to be generated
            $ret="+".$ret;
        } elsif( ($references_flags{$index} & $REF_PUBLIC)==0 ) {
            # Add star for references to private resources (as if that makes it okay to reference private resources...)
            $ret="*".$ret;
        }
    }

    return $ret;
}

sub format_xml_styleref
{
    my( $index, $translation )=@_;

    exists( $references{$index} ) or
            die sprintf "Attribute points to theme resource 0x%08x which doesn't exist", $index;

    $references{$index} =~ '^([^:/]+):([^:/]+)/([^:/]+)$' or
            die "Invalid reference $references{$index}";


    my( $package, $class, $name )=($1, $2, $3);

    exists $translation->{$package} or
            die "Attribute $references{$index} belongs to undefined namespace";
    $class eq "attr" or die "Style reference not to attribute $references{$index}";

    return "$translation->{$package}:attr/$name";
}
