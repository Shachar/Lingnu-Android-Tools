#!/usr/bin/perl

use Getopt::Long;
use File::Basename;
use File::Path qw(make_path);
use POSIX;

use feature "switch";

# Hashes for tracking the cross references
my %references, %framework_references;
my %references_flags, %framework_refrences_flags;
my %attrib_bags;

my %class_map=(
        raw=>undef,
        layout=>undef,
        xml=>undef,
        id=>\&parse_id_value,
        string=>\&parse_string_value,
        dimen=>\&parse_dimen_value,
        color=>\&parse_color_value,
        drawable=>\&parse_color_value,
    );

my %type_map=(
        8=>"bool",
    );

$REF_PUBLIC=    0x40000000;
$REF_HARDCODE=  0x80000000;
$REF_INTERNAL=  0x00000001;
$REF_NOEXPORT=  0x00000002;
$REF_SPEC=      0x00000004;
$REF_PLUS=      0x00000008;

# Hard code null
$framework_references{0}="null";
$framework_references_flags{0}=$REF_PUBLIC|$REF_HARDCODE;

# Resource type open file descriptors
my %type_files;

sub help
{
    print STDERR <<EOM;
zzos [options] apk...

Options:
--framework     Given APK provides framework for this APK
--output        directory where to create the extracted APK dirs. Default is current directory.
EOM
    exit 1;
}

my (@framework_names, $outdir);

$outdir=".";

GetOptions("framework=s" => \@framework_names, "output=s" => \$outdir ) or help();

for( @framework_names ) {
    read_resources( $_, $outdir, 1 ) or die "Failed to read framework resources for $_";
    %framework_references = %references;
    %framework_references_flags = %references_flags;
}

my ($apkpath, $delayed_fail);
my $delayed_fail=0;
while( $apkpath = shift @ARGV ) {
    # For each APK to be processed
    my ($apkname, $apkdir ) = fileparse( $apkpath, ( ".apk" ) );

    if( process_apk( $apkpath, "$outdir/$apkname" ) ) {
        $delayed_fail = 1;
        print STDERR "process_apk failed for $apkname\n";
    }
}

exit $delayed_fail;

sub process_apk
{
    my ( $apkpath, $outdir ) = @_;

    if( !mkdir "$outdir" ) {
        print STDERR "Failed to create directory $outdir: $!\n";
        return 1;
    }

    # List of files to be unzipped as they are
    my @ziplist;
    print STDOUT "Processing $apkpath\n";

    if( ! read_resources( $apkpath, $outdir, 0 ) ) {
        return 1;
    }

    # Get a list of files in the package
    if( ! open( APKLIST, "-|", "aapt", ("l", $apkpath)) ) {
        print STDERR "Failed to open $apkpath: $!\n";

        return 1;
    }

    # Scan all the files in the APK
    while( <APKLIST> ) {
        chomp;

        if( m/^resources.arsc$/ ) {
            # Do nothing. We handle this file through aapt dump resources.
        } elsif( m'^.*\.xml$' ) {
            if( !xml_decompile( $apkpath, $_, $outdir ) ) {
                return 1;
            }
        } else {
            push @ziplist, $_;
        }
    }

    close APKLIST;

    # Extract all of the files that need simple extraction
    system "unzip", ( "-q", $apkpath, @ziplist, "-d", $outdir );

    return dump_values( $apkpath, $outdir );
}

sub read_resources
{
    my ( $apkpath, $outdir, $framework ) = @_;

    # Inherit all of the framework references
    %references = %framework_references;
    %references_flags = %framework_references_flags;

    open RESFILE, "-|", "aapt", ( "d", "--values", "resources", $apkpath ) or
            die "Failed to extract resources";

    my $state=0;
    my ($counter, $bag_index);
    my $bag;
    while( <RESFILE> ) {
        chomp;

        my ($index, $package, $str);
        my $flags=$REF_INTERNAL;

        $index=undef;

        # The states are ordered so that if we decide to go out of a state, we have a chance to
        # process the same line by different parts of the code. The result is slightly less
        # readable order of states
        if( $state == 2 ) {
            # Inside bag
            if( m'#(\d+) \(Key=0x([0-9a-f]{8})\): \(color\) #([0-9a-f]{8})' ) {
                if( $1 != 0 ) {
                    $bag->{hex($2)}=hex($3);
                }

                $counter--;
            } else {
                die "Inside bag, got unparsable \"$_\"" if( $counter>0 );
            }

            if( $counter == 0 ) {
                $state = 0;
                if( scalar keys %$bag ) {
                    $attrib_bags{$bag_index} = $bag;
                }
            }
        }

        if( $state == 1 ) {
            # Start of bag
            if( m'Parent=0x[0-9a-f]{8}, Count=(\d+)' ) {
                $state = 2; # Cleanly inside the bag
                $counter = sprintf "%d", $1;
                $bag = {};
            } else {
                die "Line \"$_\" inside bag";
                $state = 0;
            }
        }

        if( $state == 0 ) {
            # Base state - usual processing
            if( m'Package Group \d+ id=\d+ packageCount=\d+ name=(.+)$' ) {
                if( !$framework ) {
                    # If this is not a framework APK read, set the package name
                    $package_name=$1;
                } else {
                    $package_name=undef;
                }
            } elsif( m"(spec )?resource 0x([0-9a-f]{8}) ([-a-zA-Z.]+):([^:/]+)/([^:]+): flags=0x([0-9a-f]+)" )
            {
                ($index, $package, $str)=( hex($2), $3, "$4/$5");

                if( $1 ) {
                    $flags|=$REF_SPEC;
                }

                if( (hex($6)&0x40000000)!=0 ) {
                    $flags|=$REF_PUBLIC;
                }

                if( exists( $references{$index} ) ) {
                    die "Reference 0x$2 refers once to $references{$index} and once to $package:$str";
                            # if ($references{$index} ne "$package:$str");
                } else {
                    if( $package ne $package_name ) {
                        # An external symbol defined inside our package
                        $flags|=$REF_NOEXPORT|$REF_PLUS;
                        # $str="$package:$str";
                    }

                    $references{$index}="$package:$str";

                    $references_flags{$index}=$flags;
                }
            } elsif( m"(spec )?resource 0x([0-9a-f]{8}) ([-a-zA-Z\.]+):([^:/]+)/([^:]+): <bag>( \(PUBLIC\))?" )
            {
                ($index, $package, $type, $str)=( hex($2), $3, $4, $5 );

                if( $1 ) {
                    $flags|=$REF_SPEC;
                }

                if( $6 ) {
                    $flags|=$REF_PUBLIC;
                }

                if( $type eq "attr" ) {
                    # We don't care about style bags at this point
                    $state=1; # Start of bag
                    $bag_index = "$package:$str";
                }
            } else {
            }
        }
    }

    close RESFILE;

    return 1;
}

sub xml_decompile
{
    my( $apkpath, $filename, $outdir ) = @_;
    my $error;

    make_path( dirname("$outdir/$filename"), { error => \$error } );
    if( @$error ) {
        print STDERR "Error creating ".dirname("$outdir/$filename").": $!\n";

        return 0;
    }

    if( !open XMLFILE, "-|", "aapt", ("d", "xmltree", $apkpath, $filename) ) {
        print STDERR "Failed to dump XML tree $filename\n";
        return 0;
    }
    if( ! open OUTFILE, ">", "$outdir/$filename" ) {
        print STDERR "Failed to create XML file $outdir/$filename: $!\n";

        close XMLFILE;
        return 0;
    }

    print STDOUT "  Generating $filename\n";

    print OUTFILE '<?xml version="1.0" encoding="utf-8"?>'."\n";
    my @elements=();
    my @schemas;
    my $current_level=-1;
    my $element_open=0;
    my $line_number=0;

    while(<XMLFILE>) {
        chomp;
        $line_number++;
        given ($_) {
            when(/^( *)N: ([^=]+)=(.*)$/) {
                local $new_level=length $1;
                $new_level/=2;
                local $firstline=1;
                while( $current_level>=$new_level ) {
                    # Close all pending open Elements
                    if( $elements[$current_level] ) {
                        print OUTFILE " "x($current_level*2) if !$firstline;

                        if( $element_open ) {
                            print OUTFILE " />\n";
                            $element_open=0;
                        } else {
                            print OUTFILE "</$elements[$current_level]>\n";
                        }
                        $firstline=0;
                    }
                    --$current_level;
                }

                if( $element_open ) {
                    # Close pending elements
                    print OUTFILE ">\n";
                    $element_open=0;
                }

                $new_level<=$current_level+1 or
                        die("Jumped for level $current_level to $new_level in one go at $filename:$line_number");
                $current_level=$new_level;
                $elements[$new_level]="";
                push( @schemas, "xmlns:$2=\"$3\"");
            }
            when(/^( *)E: ([^ ]+)/) {
                # Element
                local $new_level=length $1;
                $new_level/=2;
                local $firstline=1;
                while( $current_level>=$new_level ) {
                    # Close all pending open Elements
                    if( $elements[$current_level] ) {
                        print OUTFILE " "x($current_level*2) if !$firstline;

                        if( $element_open ) {
                            print OUTFILE " />\n";
                            $element_open=0;
                        } else {
                            print OUTFILE "</$elements[$current_level]>\n";
                        }
                        $firstline=0;
                    }
                    --$current_level;
                }
                $nospace=0;

                if( $element_open ) {
                    # Close pending elements
                    print OUTFILE ">\n";
                    $element_open=0;
                }

                $new_level<=$current_level+1 or 
                        die("Jumped for level $current_level to $new_level in one go at $filename:$line_number");

                $current_level=$new_level;
                $elements[$current_level]=$2;
                print OUTFILE "$1<$2";
                for( @schemas ) {
                    print OUTFILE " $_";
                }
                @schemas=(); # Empty the array
                        $element_open=1;
            }
            when(/^( *)A: ([^)]+)(\(0x[0-9a-f]+\))?=(.*)$/) {
                # An attribute - we need to parse to find out which
                # Attribute with value
                $element_open or die "Attribute with no open element at $filename:$line_number";

                my $val=parse_attribute($4, $2);

                print OUTFILE "\n$1  $2=\"$val\"";
            }
            when(/^( *)C: "(.*)"$/) {
                # Tag content
                $element_open or die "Content with no open element at $filename:$line_number";

                # Unescape the string, and escape it differently
                my $content=$2;
                $content=~s/\\n/\n/g;
                $content=~s/\\t/\t/g;
                $content=~s/\\\\/\\/g;
                $content=~s/&/&amp;/g;

                print OUTFILE ">$content";
                $element_open=0;
                $nospace=1;
            }
            when(/^Adding resources to ResTable:/) {
                # Administrative messages
            }
            default {
                die "Unknown line at $filename:$line_number: \"$_\"";
            }
        }
    }

    if( $element_open ) {
        # Close pending elements
        print OUTFILE ">\n";
        $element_open=0;
    }
    while( $current_level>=0 ) {
        # Close all pending open Elements
        if( $elements[$current_level] ) {
            print OUTFILE " "x($current_level*2) if !$nospace;
            $nospace=0;
            print OUTFILE "</$elements[$current_level]>\n";
        }
        --$current_level;
    }

    close XMLFILE;
    close OUTFILE;

    return 1;
}

sub reparse_attrib
{
    my ( $attrib, $val ) = @_;
    $val = $val * 1;

    # Is there anything to translate?
    if( !exists( $attrib_bags{$attrib} ) ) {
        return undef;
    }

    my ($ret, $data, $zero )=(undef, 0, undef);
    my $rev = ~$val;
    my $bag = $attrib_bags{$attrib};

    for( keys( %$bag ) ) {
        if( ($rev & $bag->{$_})==0 ) {
            if( exists( $references{$_} ) ) {
                $references{$_} =~ '/(.*)$';
                if( ($data | $bag->{$_}) != $data ) {
                    $data |= $bag->{$_};
                    $ret .= "|" if length($ret)>0;
                    $ret .= $1;
                } elsif( $bag->{$_}==0 ) {
                    $zero = $1;
                }
            }
        }

        last if( $data!=0 && $data==$val ); # We are done anyways
    }

    return $zero if $val==0 && $zero;
    return undef if $val!=$data || !defined $ret;

    return $ret;
}

# Parse a floating point type
sub parse_type_4
{
    my $val=hex($_[0]);
    my $value=0.0;

    # Zero is a special case in FP
    if( $val!=0 ) {
        # 1 bit of sign, 8 bits of exponent, 23 bits of mantissa
        my $man=$val % 0x800000;
        $man/=2**23;
        $man+=1;

        $val>>=23;

        my $exp=$val % 0x100;
        $exp-=0x7f;
        $val>>=8;

        $value=$man*2**$exp;

        if( $val ) {
            $value= -$value;
        }
    }

    return $value;
}

# Parse a dimension type
sub parse_type_5
{
    my $val=signedhex($_[0]);

    # Extract the value type
    my $value=$val/256;
    $value+=0.5;
    $value=floor($value);
    my $unit;

    # Check which unit to use
    given( $val & 0x0f ) {
        when(0) { $unit='px'; }
        when(1) { $unit='dip'; }
        when(2) { $unit='sp'; }
        when(3) { $unit='pt'; }
        when(4) { $unit='in'; }
        when(5) { $unit='mm'; }
        default { die "$filename:$line_number: Unknown unit for type: \"$_[0]\"\n"; }
    }

    # Check what split between fraction and whole
    given( ($val & 0x30)>>4 ) {
        when(0) { };                        # Integer
        when(1) { $value/=128 };            # Fix point 7 bit shift
        when(2) { $value/=32768 };          # Fix point 15 bit shift
        when(3) { $value/=8,388,608 };      # Fix point 23 bit shift
    }

    return "$value$unit";
}

# Parse fraction type
sub parse_type_6
{
    my $val=signedhex($_[0]);

    # 4 bit relation
    my $relation=$val&0x7;
    $val >>= 4;
    # 4 bit fraction type
    my $type=$val&0x7;
    $val >>= 4;

    # 23 bit mantissa
    my $mantissa=$val&((1<<23)-1);
    $val >>= 23;

    # $val is zero if the number is positive
    if( $val ) {
        # Number is negative - perform two's complement on it to turn it positive
        $mantissa ^= (1<<23)-1;
        $mantissa ++;
        $val="-";
    } else {
        $val="";
    }

    given( $type ) {
        when( 0x0 ) {
            # Number is whole - do nothing
        }
        when( 0x1 ) {
            # 16 bit whole, 7 bit fraction
            $mantissa /= 2.0 ** 7;
        }
        when( 0x2 ) {
            # 8 bit whole, 15 bit fraction
            $mantissa /= 2.0 ** 15;
        }
        when( 0x3 ) {
            # 23 bits of fraction
            $mantissa /= 2.0 ** 23;
        }
        default {
            die "While parsing fraction type, unknown type $type";
        }
    }

    $mantissa *= 100; # Turn it into percents

    given( $relation ) {
        when( 0 ) {
            $relation="";
        }
        when( 1 ) {
            $relation="p";
        }
        default {
            die "While parsing fraction type, unknown relation $relation at $filename:$line_number";
        }
    }

    return "$val$mantissa%$relation";
}

# Parse type boolean
sub parse_type_12
{
    my $val=signedhex($_[0]);

    if( $val==0 ) {
        return "false";
    } elsif( $val==-1 ) {
        return "true";
    } else {
        die "Boolean is neither 0 nor -1";
    }
}

# Parse type ARGB8
sub parse_type_1c
{
    my $val=hex($_[0]);

    return sprintf "#%08x", $val;
}

# Parse type RGB8
sub parse_type_1d
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    $val&=0x00ffffff;

    return sprintf "#%06x", $val;
}

# Parse type ARGB4
sub parse_type_1e
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    my $value=0;

    $val>>=4;
    $value=$val&0xf;

    $val>>=4;
    $value|=$val&0xf0;

    $val>>=4;
    $value|=$val&0xf00;

    $val>>=4;
    $value|=$val&0xf000;

    return sprintf "#%04x", $value;
}

# Parse type RGB4
sub parse_type_1f
{
    my $val=hex($_[0]);

    # Mask out the Alpha channel
    my $value=0;

    $val>>=4;
    $value=$val&0xf;

    $val>>=4;
    $value|=$val&0xf0;

    $val>>=4;
    $value|=$val&0xf00;

    return sprintf "#%03x", $value;
}

sub parse_attribute
{
    my ($value, $attrib)=@_;

    given( $value ) {
        when(/^.*\(Raw: "(.*)"\)$/) {
            return $1;
        }
        when(/^\(type 0x4\)0x(.*)$/) {
            return parse_type_4($1);
        }
        when(/^\(type 0x5\)0x(.*)$/) {
            return parse_type_5($1);
        }
        when(/^\(type 0x6\)0x(.*)$/) {
            return parse_type_6($1);
        }
        when(/^\(type 0x10\)0x(.*)$/) {
            my $val=reparse_attrib( $attrib, hex($1) );

            if( !defined($val) ) {
                $val=signedhex($1);
            }

            return $val;
        }
        when(/^\(type 0x11\)0x(.*)$/) {
            my $val=reparse_attrib( $attrib, hex($1) );

            if( !defined($val) ) {
                $val=sprintf "0x%x", hex($1);
            }

            return $val;
        }
        when(/^\(type 0x12\)0x(.*)$/) {
            return parse_type_12($1);
        }
        when(/^\(type 0x1c\)0x(.*)$/) {
            return parse_type_1c($1);
        }
        when(/^\(type 0x1d\)0x(.*)$/) {
            return parse_type_1d($1);
        }
        when(/^\(type 0x1e\)0x(.*)$/) {
            return parse_type_1e($1);
        }
        when(/^\(type 0x1f\)0x(.*)$/) {
            return parse_type_1f($1);
        }
        when(/^\@0x([0-9a-f]+)$/) {
            # Resource reference
            my $res=hex($1);

            exists( $references{$res} ) or
                    die "Attribute points to resource 0x$1 which doesn't exist";

            return "\@$references{$res}";
        }
        when(/^\?0x([0-9a-f]+)$/) {
            # Theme reference
            exists( $references{hex($1)} ) or 
                    die "Attribute points to theme resource 0x$1 which doesn't exist";

            return "?$references{hex($1)}";
        }
        default {
            die "Unparsable line \"$_\"";
        }
    }
}

# Convert all 32 bit values to signed 32 bit, regardless of whether our perl implementation is 32
# or 64 bit.
sub signedhex {
    local $ret=hex(shift(@_));

    if ($ret>=0x80000000) {
        $ret-=0x100000000;
    }

    return $ret;
}

sub printhash {
    my ($hash) = @_;

    my $ret="{ ";
    for ( keys( %$hash ) ) {
        $ret .= $_."=>".$$hash{$_}." ";
    }

    $ret.="}";

    return $ret;
}

sub dump_values
{
    my ( $apkpath, $outdir )=@_;

    if( ! open RESOURCES, "-|", "aapt", ( "d", "--values", "resources", $apkpath) ) {
        print STDERR "Failed to dump resources from $apkpath: $!\n";

        return 1;
    }

    my $state=0;
    my $configname=undef;
    my ($class, $name, $type);
    my $error;

    while( <RESOURCES> ) {
        chomp;
        
        if( m'^ *config (\d+)( .*)?$' ) {
            # Start of new configuration block
            close_pending_files(); # Close all open pending files
            $configname=parse_config_name($2);
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):([^/]+)/([^:]+): t=0x([0-9a-f]+)' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:$3/$4";
            ($class, $name, $type)=( $3, $4, $5 );
            $state = 1;
        } elsif( defined $name && $state==1 ) {
            if( !parse_values( $class, $name, $type, $_, $outdir, $configname ) ) {
                return 1;
            }

            ($class, $name, $type)=(undef, undef, undef);
            $state=0;
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):array/([^:]+): <bag>$' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:array/$3";

            $class="array";
            $name=$3;
            $state=2;
        } elsif( $state==2 ) {
            m'^ *Parent=0x[0-9a-f]+, Count=(\d+)$' or
                    die "Unexpected text \"$_\" after array start";
            $count=$1+0; # Make sure perl knows it is, indeed, an integer
            $state=3;

            write_array_open($name, $outdir, $configname);

            if( $count==0 ) {
                write_array_close($name);
                $state=0;
            }
        } elsif( $state==3 ) {
            m'^ *#(\d+) \(Key=0x[0-9a-f]+\): (.*)$' or
                    die "Unexpected text \"$_\" for array item";

            write_array_item($2);

            if( --$count == 0 ) {
                write_array_close($name);
                $state=0;
            }
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):attr/([^:]+): <bag>' && 0 ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference. Was $references{hex($1)} now $2:attr/$3"
                    if $references{hex($1)} ne "$2:attr/$3";

            $class="attr";
            $name=$3;
            $state=4;
        } elsif( $state==4 ) {
            m'^ *Parent=0x[0-9a-f]+, Count=(\d+)$' or
                    die "Unexpected text \"$_\" after attr start";

            $count=$1+0; # Make sure perl knows it is, indeed, an integer
            die "Attribute with count different than 1" if $count!=1;

            $state++;

            if( $count==0 ) {
                $state=0;
            }
        } elsif( $state==4 ) {
            m'^ *#(\d+) \(Key=0x[0-9a-f]+\): \(color\) #(.*)$' or
                    die "Unexpected text \"$_\" for attr item";

            write_attr($name, hex($2));

            if( --$count == 0 ) {
                $state=0;
            }
        } elsif( m'^ *resource 0x([0-9a-f]+) ([^:]+):style/([^:]+): <bag>$' ) {
            die "Unexpected resource value" if ! defined $configname;

            die "Resource define non-package value" if $2 ne $package_name;
            die "First time defined with value" if !exists $references{hex($1)};
            die "Inconsistent name of reference" if $references{hex($1)} ne "$2:style/$3";

            $class="style";
            $name=$3;
            $state=30;
        } elsif( $state==30 ) {
            m'^ *Parent=0x[0-9a-f]+, Count=(\d+)$' or
                    die "Unexpected text \"$_\" after array start";
            $count=$1+0; # Make sure perl knows it is, indeed, an integer
            $state=31;

            write_style_open($name, $outdir, $configname);

            if( $count==0 ) {
                write_style_close($name);
                $state=0;
            }
        } elsif( $state==31 ) {
            m'^ *#(\d+) \(Key=0x([0-9a-f]+)\): (.*)$' or
                    die "Unexpected text \"$_\" for style item";

            write_style_item($3, hex($2));

            if( --$count == 0 ) {
                write_style_close($name);
                $state=0;
            }
        } else {
            # XXX print "$_\n";
        }
    }

    close( RESOURCES );

    close_pending_files();

    return 0;
}

sub parse_config_name
{
    my ($string)=@_;

    my $ret="";

    # The order here is important! See http://developer.android.com/guide/topics/resources/providing-resources.html#AlternativeResources

    if( $string=~/mcc=(\d+)/ ) {
        $ret.="-mcc$1";
    }
    if( $string=~/mnc=(\d+)/ ) {
        $ret.="-mnc$1";
    }
    if( $string=~/lang=([a-z]+)/ ) {
        $ret.="-$1";
    }
    if( $string=~/cnt=([A-Z]+)/ ) {
        $ret.="-r$1";
    }
    if( $string=~/sz=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/lng=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/orient=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/type=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/night=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/density=(\S+)/ ) {
        if( $1==120 ) {
            $ret.="-ldpi";
        } elsif( $1==160 ) {
            $ret.="-mdpi";
        } elsif( $1==240 ) {
            $ret.="-hdpi";
        } elsif( $1==320 ) {
            $ret.="-xhdpi";
        } elsif( $1 eq "no" ) {
            $ret.="-nodpi";
        } else {
            die "Unsupported density mode $1: $string";
        }
    }
    if( $string=~/touch=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/keyhid=(\d+) \((\S+)\)/ ) {
        $ret.="-keys$2";
    }
    if( $string=~/kbd=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/navhid=(\d+) \((\S+)\)/ ) {
        if( $1==4 ) {
            $ret.="-navexposed";
        } elsif( $1==8 ) {
            $ret.="-navhidden";
        } else {
            die "Unsupported navigation availability value $1: $string";
        }
    }
    if( $string=~/nav=(\d+) \((\S+)\)/ ) {
        $ret.="-$2";
    }
    if( $string=~/w=(\d+) h=(\d+)/ ) {
        # Dropped from the documentation as if it never existed
        $ret.="-$1x$2";
    }
    if( $string=~/sdk=(\d+)/ ) {
        # XXX Might add code to not print if minimal version dictated by other attributes
        $ret.="-v$1";
    }

    return $ret;
}

sub open_config_file
{
    my( $class, $outdir, $configname )=@_;
    return $type_files{$class} if exists $type_files{$class};

    make_path( "$outdir/res/values$configname", { error => \$error } );
    my $fileref;
    open $fileref, ">$outdir/res/values$configname/${class}s.xml" or
            die "Failed to open res/values$configname/${class}s.xml: $!";

    print $fileref '<?xml version="1.0" encoding="utf-8"?>'."\n";
    print $fileref "<resources>\n";

    $type_files{$class}=$fileref;

    return $type_files{$class};
}

sub close_pending_files
{
    for( keys %type_files ) {
        my $fileref = $type_files{$_};
        print $fileref "</resources>\n";
        close $fileref;

        delete $type_files{$_};
    }
}

sub parse_values
{
    my( $class, $name, $type, $string, $outdir, $configname )=@_;

    die "Unknown class \"$class\"" if ! exists $class_map{$class};

    if( defined $class_map{$class} ) {
        my $fileref = open_config_file( $class, $outdir, $configname );

        ${class_map{$class}}( $name, $type, $string, $class );
    }

    return 1;
}

sub parse_id_value
{
    my( $name, $type, $string, $class )=@_;

    my $fileref = $type_files{id};
    print $fileref "  <item type=\"id\" name=\"$name\" />\n";
}

# Accept a string as reported by aapt, and issue it in a form suitable for XML output
sub escape_string
{
    my $string=$_[0];

    $string=~s/'/\\'/g;
    $string=~s/&/&amp;/g;

    return $string;
}

sub parse_string_value
{
    my( $name, $type, $string, $class )=@_;
    my $fileref = $type_files{string};

    $type=hex($type);
    if( $type==3 ) {
        # Direct UTF-8 string
        if( $string!~'^\s*\(string8\) "(.*)"$' &&
                $string!~'^\s*\(string16\) "(.*)"$' )
        {
            die "Invalid string format: \"$string\"";
        }
        print $fileref "  <string name=\"$name\">".escape_string($1)."</string>\n";
    } elsif( $type==1 ) {
        if( $string!~'^\s*\(reference\) 0x([0-9a-f]+)$' ) {
            die "Invalid string format: \"$string\"";
        }

        die "Invalid reference 0x$1" if !exists $references{hex($1)};

        print $fileref "  <string name=\"$name\">@".$references{hex($1)}."</string>\n";
    } else {
        die "Unhandled string type $type: \"$string\"";
    }
}

sub parse_dimen_value
{
    my( $name, $type, $string, $class )=@_;

    my $fileref = $type_files{dimen};

    if( $type==5 ) {
        # Processed dimension
        if( $string!~'^\s*\(dimension\) (\S+)$' ) {
            die "Invalid string format: \"$string\"";
        }
        print $fileref "  <dimen name=\"$name\">$1</dimen>\n";
    } else {
        die "Unhandled dimen type $type: \"$string\"";
    }
}

sub parse_color_value
{
    my( $name, $type, $string, $class )=@_;

    my $fileref = $type_files{$class};

    $type = hex($type);
    if( $type==0x1f || $type==0x1c || $type==0x1d ) {
        # Processed color
        if( $string!~'^\s*\(color\) (#\S+)$' ) {
            die "Invalid string format: \"$string\"";
        }
        print $fileref "  <$class name=\"$name\">$1</$class>\n";
    } elsif( $type==3 ) {
        # Do nothing. Reference to external XML
    } elsif( $type==1 ) {
        if( $string!~'^\s*\(reference\) 0x([0-9a-f]+)$' ) {
            die "Invalid reference format: \"$string\"";
        }

        die "Invalid reference 0x$1" if !exists $references{hex($1)};

        print $fileref "  <$class name=\"$name\">@".$references{hex($1)}."</$class>\n";
    } else {
        die "Unhandled color type $type: \"$string\"";
    }
}

sub write_array_open
{
    my($name, $outdir, $configname)=@_;

    my $fileref = open_config_file( "array", $outdir, $configname );

    print $fileref "  <array name=\"$name\">\n"
}

sub write_array_item
{
    my($string)=@_;

    my $fileref = $type_files{array};

    my($value,,$comment)=parse_content($string);

    if( $comment eq "" ) {
        print $fileref "    <item>$value</item>\n";
    } else {
        print $fileref "    <item>$value</item> <!-- $comment -->\n";
    }
}

sub write_array_close
{
    my($name)=@_;

    my $fileref = $type_files{array};

    print $fileref "  </array>\n\n"
}

sub write_attr
{
    my ($name, $type)=@_;
}

sub write_style_open
{
    my($name, $outdir, $configname)=@_;

    my $fileref = open_config_file( "style", $outdir, $configname );

    print $fileref "  <style name=\"$name\">\n"
}

sub write_style_item
{
    my($string, $nameref)=@_;

    die sprintf( "Key references non-existing resource 0x%08x", $nameref )
            if ! exists $references{$nameref};

    my $fileref = $type_files{style};
    my($value,$type,$comment)=parse_content($string);

    print $fileref "    <item";
    if($nameref!=0)
    {
        $references{$nameref}=~'^([^:/]+):([^:/]+)/([^:/]+)$' or
                    die "Invalid reference format $references{$nameref}";

        my ($package, $class, $name)=($1, $2, $3);
        die "Not an attribute item name \"$references{$nameref}\"" if( $class ne "attr" );

        print $fileref " name=\"$package:$name\"";

        if( $type eq "color" ) {
            # This might be a bit field/enum
            $value=~/^#(.*)$/ or die "Color $value with invalid format";

            my $tmpval=reparse_attrib( "$package:$name", hex($1) );

            if( defined $tmpval ) {
                $value=$tmpval;
                $comment="";
            }
        }
    }
    print $fileref ">$value</item>";

    if($comment ne "" ) {
        print $fileref "  <!-- $comment -->";
    }

    print $fileref "\n";
}

sub write_style_close
{
    my($name)=@_;

    my $fileref = $type_files{style};

    print $fileref "  </style>\n\n";
}

# Return a list of parsed name, type and comment (if any)
sub parse_content
{
    my($string)=@_;
    my($ret, $type, $comment);

    given( $string ) {
        when( m'^\((reference)\) 0x([0-9a-f]+)$' ) {
            $type=$1;
            my $ref=hex($2);
            die "Invalid reference 0x$ref" if ! exists $references{$ref};

            $ret="@".$references{$ref};
        }
        when( m'^\((color)\) #([0-9a-f]+)$' ) {
            # We cannot tell a color from an integer
            $type=$1;
            $ret="#$2";
            $comment="or int ".signedhex($2);
        }
        when( m'^\((string8)\) "(.*)"$' ) {
            $type=$1;
            $ret=escape_string($2);
        }
        when( m'^\((string16)\) "(.*)"$' ) {
            $type=$1;
            $ret=escape_string($2);
        }
        when( m'^\((dimension)\) (.*)$' ) {
            $type=$1;
            $ret=$2;
        }
        default {
            die "Don't know how to parse \"$_\"";
        }
    }

    return($ret, $type, $comment);
}
